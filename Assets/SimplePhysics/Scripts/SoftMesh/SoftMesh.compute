#pragma kernel Simulate
#pragma kernel ApplyImpact

StructuredBuffer<float3> _Rest;
RWStructuredBuffer<float3> _Target;
RWStructuredBuffer<float3> _Pos;
RWStructuredBuffer<float3> _Vel;



uint _VertexCount;

float _DT;
float _SpringK;
float _Damping;

// impact params
float3 _ImpactPointWS;
float3 _PushDirWS;
float _Strength;
float _Kick;
float _MaxDistance;

float4x4 _L2W;
float4x4 _W2L;

[numthreads(256, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _VertexCount)
        return;

    float3 x = _Pos[i];
    float3 xT = _Target[i];
    float3 v = _Vel[i];

    // F = -k(x-x0) - c v
    float3 springForce = -_SpringK * (x - xT);
    float3 dampingForce = -_Damping * v;

    
    float3 a = (springForce + dampingForce);

    // semi-implicit euler
    v += a * _DT;
    x += v * _DT;

    _Vel[i] = v;
    _Pos[i] = x;
}

[numthreads(256, 1, 1)]
void ApplyImpact(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _VertexCount)
        return;

    float3 xLS = _Pos[i];

    // local -> world
    float3 xWS = mul(_L2W, float4(xLS, 1.0)).xyz;

    float dist = distance(xWS, _ImpactPointWS);
    if (dist > _MaxDistance)
        return;

    // Falloff
    float t = saturate(dist / _MaxDistance);
    float w = 1.0 - t;
    w = w * w * (3.0 - 2.0 * w); // SmoothStep

    // 1) TARGET OFFSET (Delle)
    // direction in local space
    float3 pushDirLS = mul((float3x3) _W2L, _PushDirWS);

    // absolute dent offset (NICHT velocity-basiert!)
    float3 targetOffsetLS = pushDirLS * (w * _Strength);

    _Target[i] -= targetOffsetLS;

    // 2) OPTIONAL: Velocity Wobble
    float3 velKickLS = pushDirLS * (_Kick * w);
    _Vel[i] -= velKickLS;
}
