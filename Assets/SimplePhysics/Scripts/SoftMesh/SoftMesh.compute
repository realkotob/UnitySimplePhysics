#pragma kernel Simulate
#pragma kernel ApplyImpact
#pragma kernel CheckActivity

// Buffers
StructuredBuffer<float3> _Rest;
RWStructuredBuffer<float3> _Target;
RWStructuredBuffer<float3> _Pos;
RWStructuredBuffer<float3> _Vel;
RWStructuredBuffer<uint> _ActiveFlag;
uint _VertexCount;

// impact params
float3 _ImpactPointLS;
float3 _PushDirLS;
float3 _AbsScale;
float _Dent;
float _Kick;
float _MaxDistanceWS;

// Spring params
float _DT;
float _SpringK;
float _Damping;


[numthreads(256, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _VertexCount)
        return;

    float3 x = _Pos[i];
    float3 xT = _Target[i];
    float3 v = _Vel[i];

    // F = -k(x-x0) - c v
    float3 springForce = -_SpringK * (x - xT);
    float3 dampingForce = -_Damping * v;

    
    float3 a = (springForce + dampingForce);

    // semi-implicit euler
    v += a * _DT;
    x += v * _DT;

    _Vel[i] = v;
    _Pos[i] = x;
}

[numthreads(256, 1, 1)]
void ApplyImpact(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _VertexCount)
        return;

    float3 xLS = _Pos[i];

    // Local-space delta
    float3 dLS = xLS - _ImpactPointLS;

    // Approximate world-space distance using absolute scale
    // This keeps the deformation radius independent of transform scale
    float3 dWS = dLS * _AbsScale;
    float distWS = length(dWS);

    if (distWS > _MaxDistanceWS)
        return;

    // Smooth falloff based on world-space distance
    float t = saturate(distWS / _MaxDistanceWS);
    float w = 1.0 - t;
    w = w * w * (3.0 - 2.0 * w); // smoothstep

    float3 pushDirLS = normalize(_PushDirLS);

    // Apply target offset and velocity impulse in local space
    _Target[i] -= pushDirLS * (_Dent * w);
    _Vel[i] -= pushDirLS * (_Kick * w);
}

[numthreads(256, 1, 1)]
void CheckActivity(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _VertexCount)
        return;

    float3 v = _Vel[i];
    float speedSq = dot(v, v);

    // hardcoded threshold
    if (speedSq > 0.001 * 0.001)
    {
        InterlockedOr(_ActiveFlag[0], 1);
    }
}